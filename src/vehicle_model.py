#! /usr/bin/python
# -*- coding: utf-8 -*-
"""

author: qidong
"""
import rospy
import sys
import numpy as np
from campus_driving.msg import INSPVAX,stm32TX,VehState,PlanOP
import commonFcn

name = 'XS202' # include: 'A60', 'XS202'
locPlan = False # decide which kind of path is published to control module,
                    # the path generated by local planning or the wayPoint from
                    # map directly.
FORWARD = 0 # 行车方向前进
BACK = 1 # 行车方向后退

INIT = 0 # 默认值
NORMAL = 1 # 正常行车
STOP = 2 # 停车
STOP_SAFE = 4 # 避障停车
DECELERATE = 9 # 舒适匀减速，底层MCU仍为NORMAL
# 整车
# vehicle param: http://www.dfev.com/publish/pv/product_config.jsp?id=91420
L = 2.7  # [m] 轴距
LENGTH = 4.68 # [m] 车长
WIDTH = 1.72  # [m] 车宽
HEIGHT = 1.515 # [m] 车高
MASS = 1470 # [kg] 车重
# 转向系统
Delta2Steer = 8. # 前轮转角到方向盘转角的增益
T_lag = 2.5      # [s] 转向滞后时间
if name == 'A60':
    MAX_STEER_ANGLE = 500. # deg
    MIN_STEER_ANGLE = -MAX_STEER_ANGLE
    MAX_STEER_RATE = 0.2  # rad/s
    MIN_STEER_RATE = -MAX_STEER_RATE
    # 开始寻迹控制位初始值
    start_trace_init = True
    DIST_OBST_OFFSET_FORWARD = 0.
    DIST_OBST_OFFSET_BACK = 0.
else:
    MAX_STEER_ANGLE = 745.  # 745 < 3.5*360 = 1260
    MIN_STEER_ANGLE = -MAX_STEER_ANGLE
    MAX_STEER_RATE = 0.2  # rad/s
    MIN_STEER_RATE = -MAX_STEER_RATE
    start_trace_init = False
    DIST_OBST_OFFSET_FORWARD = 2.9 # 栅格图原点距车辆最前方距离
    DIST_OBST_OFFSET_BACK = 3.25 # 栅格图原点距车辆最后端距离
# 制动系统
AEBenable = False # enable AEB function
VelCtrEnable = True # enable speed control, if set False, then IAI and DA reset to MIN.
                    # 配合模式开关关闭(油门),右边紧急按钮按下(方向盘)，可完全屏蔽自动模式
                    # 后期可采集模式开关，本控制量可取消
MAX_DA = 1.95   # 踏板电压高
MIN_DA = 0.3      # 踏板电压低 0.333
MAX_IAI_S = 70.  # IAI行程终点 79
MIN_IAI_S = 11.   # IAI行程起点 16-1
DEAD_IAI_S = 17.
MAX_IAI_V = 170.  # maxmmiun speed is aroud 180, comfortable speed is 10 when braking
MIN_IAI_V = 0.
# 动力总成
shift_P = 1   # stm32无数据时默认
shift_R = 2
shift_N = 3
shift_D = 4

Hz_CPT = 50.    # corrimudatasa command Hz
pitchDeqGLB = commonFcn.meanFilter(50) # 50 = 1s * 50hz
yawRateDeqGLB = commonFcn.meanFilter(25) # 50 = 1s * 50hz
rawAzimuthGLB = 0.

class State(object):

    def __init__(self):
        self.speed = 0.
        self.azimuth = 0.
        self.pitch = 0.
        self.w_z = 0.
        self.a_x = 0.
        self.x = 0.
        self.y = 0.
        self.xVibr = 0.
        self.yVibr = 0.

    def update(self):
        global rawAzimuthGLB
        self.speed = sensor['vel_cpt']
        # 后退时，航向角修正
        '''
        cpt航向是由正北顺时针旋转到车辆纵轴x的角度，程序需要的航向是由正东逆时针旋转到ｘ的角度
        确保每一步临时计算的航向都在0-360范围内
        '''
        if name == 'A60':
            rawAzimuth = sensor['azimuth']
        else:
            rawAzimuth = sensor['azimuth'] + 0.
            if rawAzimuth >= 90.:
                rawAzimuth = rawAzimuth - 90.
            else:
                rawAzimuth = (rawAzimuth - 90.) + 360.
            # if sensor['azimuth'] >= 90.:
            #     rawAzimuth = sensor['azimuth'] - 90.
            # else:
            #     rawAzimuth = (sensor['azimuth'] - 90.) + 360.
            if sensor['curDirDrive'] == BACK:
                # 通过角度传感器和碾子航向反求车身原始航向
                # 输入碾子航向为纵向朝前,角度传感器zuozuhanweizheng
                # 因angleSensor符号未知，所以会出现两种超限情况
                rawAzimuth = rawAzimuth + sensor['angleSensor']
                if rawAzimuth > 360.:
                    rawAzimuth -= 360.
                elif rawAzimuth < 0.:
                    rawAzimuth += 360.
                else:
                    pass
        self.azimuth = (360.-rawAzimuth)+90.
        if self.azimuth > 360.:
            self.azimuth -= 360.
        rawAzimuthGLB = self.azimuth
        if sensor['curDirDrive'] == BACK:
            if self.azimuth > 180.:
                self.azimuth = self.azimuth - 180.
            else:
                self.azimuth = self.azimuth + 180.
        # 对pitch零点修正和采用平均值滤波
        # on level road is -2.717. on campus, min is -9.28
        self.pitch = pitchDeqGLB.update(sensor['pitch'] + 2.717)
        self.w_z = yawRateDeqGLB.update(sensor['w_z'] * Hz_CPT)
        # 倒车，加速度反向
        self.a_x = sensor['a_y'] * Hz_CPT
        if sensor['shift'] == shift_R and sensor['curDirDrive'] == BACK:
            self.a_x *= -1
        positionM30 = {'x':sensor['x'], 'y':sensor['y']}
        vibrAzimuth = rawAzimuthGLB
        angleSensor = sensor['angleSensor']
        pointVibrGLb, pointRearGLb = \
            self.calcCoordinate(positionM30,vibrAzimuth,angleSensor)
        self.xVibr, self.yVibr = pointVibrGLb
        if sensor['curDirDrive'] == BACK:
            self.x, self.y = pointRearGLb
        else:
            self.x, self.y = pointVibrGLb
        # print 'dist', np.linalg.norm(pointVibrGLb - [positionM30['x'],positionM30['y']])
        # if sensor['curDirDrive'] == BACK:
        #     pointAnchor = np.array([-0.115, 0.])
        # else:
        #     pointAnchor = np.array([0.115, 0.])
        # position = {'x':sensor['x'], 'y':sensor['y'],'azimuth':self.azimuth}
        # pointAnchorGlobal = commonFcn.local_2_global_point(position,pointAnchor)
        # self.x, self.y = pointAnchorGlobal

    def calcCoordinate(self,positionM30,vibrAzimuth,angleSensor):
        theta1 = vibrAzimuth  # 与x轴逆时针
        theta2 = angleSensor # 编码器左转为正，右转为负
        theta3 = theta1 - sensor['angleSensor'] # 与x轴逆时针，且朝前
        if theta3 > 360.:
            theta3 -= 360.
        elif theta3 < 0.:
            theta3 += 360.
        else:
            pass
        l0 = 0.115 # M30到转轴距离
        l1 = 1.7 # 转轴到碾子中心距离
        l2 = 1.7 # 转轴到后轴距离
        position0 = {'x':positionM30['x'], 'y':positionM30['y'], 'azimuth':theta3}
        point_cLoc = np.array([l0,0.])
        point_cGlb = commonFcn.local_2_global_point(position0,point_cLoc)
        position_c = {'x':point_cGlb[0], 'y':point_cGlb[1], 'azimuth':theta1}
        pointVibrLoc = np.array([l1,0.])
        pointVibrGLb = commonFcn.local_2_global_point(position_c,pointVibrLoc)
        position_c = {'x':point_cGlb[0], 'y':point_cGlb[1], 'azimuth':theta3}
        pointRearLoc = np.array([-l2,0.])
        pointRearGLb = commonFcn.local_2_global_point(position_c,pointRearLoc)

        return pointVibrGLb, pointRearGLb

    def publish(self):
        msgState = VehState()
        msgState.x = self.x    # [m] Pointing to due east
        msgState.y = self.y    # [m] Pointing to due north
        msgState.xVibr = self.xVibr
        msgState.yVibr = self.yVibr
        msgState.z = sensor['z']    # [m] up
        msgState.roll = sensor['roll']  # [deg]
        msgState.pitch = self.pitch    # [deg] on level road is -2.717. on campus, min is -9.28
        msgState.azimuth = self.azimuth    # [deg] counterclockwise from East 0-360
        msgState.rawAzimuth = rawAzimuthGLB

        msgState.w_x = sensor['w_y'] * Hz_CPT   # [rad/s]  # 坐标互换
        msgState.w_y = sensor['w_x'] * Hz_CPT   # [rad/s]
        msgState.w_z = self.w_z   # [rad/s]
        msgState.a_x = self.a_x    # [m/ss]  # 坐标互换
        msgState.a_y = -sensor['a_x'] * Hz_CPT    # [m/ss] # Pointing to left
        msgState.a_z = sensor['a_z'] * Hz_CPT   # [m/ss]

        msgState.steer_angle = sensor['steer_angle']   # [deg] current steering angle, clockwise -540 - 540
        msgState.speed = self.speed     # [km/h] >= 0
        msgState.brake_stat = sensor['brake_stat'] # 0: default; 1:brake
        msgState.shift = sensor['shift'] # 1: P; 2: R; 3: N; 4: D
        msgState.curDirDrive = sensor['curDirDrive']
        msgState.header.stamp = rospy.Time.now()
        statePub.publish(msgState)

def getCurPosition(data):
    sensor['x'] = data.x    # [m] Pointing to due east
    sensor['y'] = data.y    # [m] Pointing to due north
    sensor['z'] = data.altitude # [m] up
    sensor['roll'] = data.roll  # [deg]
    sensor['pitch'] = data.pitch    # [deg]
    if name == 'A60':
        # for cpt
        sensor['azimuth'] = data.azimuth    # [deg] clockwise 0-360
        north_velocity = data.north_velocity
        east_velocity = data.east_velocity
        up_velocity = data.up_velocity
        velocity_ins = np.sqrt(north_velocity**2+east_velocity**2+up_velocity**2)
        sensor['vel_cpt'] = velocity_ins*3.6 # [km/h] >= 0

def getVehCAN(data):
    sensor['steer_angle'] = data.steer_angle
    sensor['vel_can'] = data.velocity_CAN
    sensor['brake_stat'] = data.brake_stat
    sensor['shift'] = data.shift_stat

def getAzimuth(data):
    sensor['azimuth'] = data.azimuth    # [deg] clockwise 0-360

def getModeDrive(data):
    sensor['curDirDrive'] = data.curDirDrive

def getAngleSensor(data):
    sensor['angleSensor'] = data.angle

def getAcc(data):
    sensor['w_x'] = data.w_x
    sensor['w_y'] = data.w_y
    sensor['w_z'] = data.w_z
    sensor['a_x'] = data.a_x
    sensor['a_y'] = data.a_y
    sensor['a_z'] = data.a_z

if __name__ == '__main__':
    rospy.init_node('vehicle', anonymous = False)
    sensor = {'x':0., 'y':0., 'z':0., 'roll':0., 'pitch':0., 'azimuth':0., \
                'vel_cpt':0., 'vel_can':0., 'brake_stat':False, 'shift':shift_P, \
                'steer_angle':0., 'curDirDrive':FORWARD, 'angleSensor':0., \
                'w_x':0., 'w_y':0., 'w_z':0., 'a_x':0., 'a_y':0., 'a_z':0.}
    if name == 'A60':
        rospy.Subscriber("cpt_ins", INSPVAX, getCurPosition)
    else:
        rospy.Subscriber("M30_gps", INSPVAX, getCurPosition)
        rospy.Subscriber("Double_Antennainsx", INSPVAX, getAzimuth)
    rospy.Subscriber("cpt_corr", INSPVAX, getAcc)
    rospy.Subscriber("stm32TX_info", stm32TX, getVehCAN)
    rospy.Subscriber("planOutput", PlanOP, getModeDrive)
    rospy.Subscriber("angleSensor", INSPVAX, getAngleSensor)

    statePub = rospy.Publisher("vehState", VehState, queue_size =10)

    state = State()
    rate = rospy.Rate(50)
    while not rospy.is_shutdown():
        state.update()
        state.publish()
        rate.sleep()
    rospy.spin()    #rospy.spin()作用是当节点停止时让python程序退出，和C++ spin的作用不同
#    sys.exit()
